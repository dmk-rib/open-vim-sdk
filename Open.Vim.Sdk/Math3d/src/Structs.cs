
// AUTOGENERATED FILE: Do not edit directly, instead edit Structs.tt

// MIT License
// Copyright (C) 2019 VIMaec LLC.
// Copyright (C) 2019 Ara 3D. Inc
// https://ara3d.com
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.
// ReSharper disable CompareOfFloatsByEqualityOperator

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Vim.Math3d
{
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Vector2 : IEquatable< Vector2 >
    {
        [DataMember]
        public readonly float X;
        [DataMember]
        public readonly float Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector2(float x, float y) { X = x; Y = y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Vector2 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Vector2(X = {X}, Y = {Y})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out float x, out float y) {x = X; y = Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Vector2 x) => X == x.X && Y == x.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Vector2 x0, Vector2 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Vector2 x0, Vector2 x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Vector2 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance);    
        public static Vector2 Zero = new Vector2(default, default);
        public static Vector2 MinValue = new Vector2(float.MinValue, float.MinValue);
        public static Vector2 MaxValue = new Vector2(float.MaxValue, float.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector2 SetX(float x) => new Vector2(x, Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector2 SetY(float x) => new Vector2(X, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator +(Vector2 value1, Vector2 value2) => new Vector2(value1.X + value2.X,value1.Y + value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator +(Vector2 value1, float value2) => new Vector2(value1.X + value2,value1.Y + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator +(float value1, Vector2 value2) => new Vector2(value1 + value2.X,value1 + value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator -(Vector2 value1, Vector2 value2) => new Vector2(value1.X - value2.X,value1.Y - value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator -(Vector2 value1, float value2) => new Vector2(value1.X - value2,value1.Y - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator -(float value1, Vector2 value2) => new Vector2(value1 - value2.X,value1 - value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator *(Vector2 value1, Vector2 value2) => new Vector2(value1.X * value2.X,value1.Y * value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator *(Vector2 value1, float value2) => new Vector2(value1.X * value2,value1.Y * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator *(float value1, Vector2 value2) => new Vector2(value1 * value2.X,value1 * value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator /(Vector2 value1, Vector2 value2) => new Vector2(value1.X / value2.X,value1.Y / value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator /(Vector2 value1, float value2) => new Vector2(value1.X / value2,value1.Y / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator /(float value1, Vector2 value2) => new Vector2(value1 / value2.X,value1 / value2.Y);
        public static Vector2 One = new Vector2(1f);
        public static Vector2 UnitX = Zero.SetX(1f);
        public static Vector2 UnitY = Zero.SetY(1f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector2(float value) : this(value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector2 operator -(Vector2 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(Vector2 value1, Vector2 value2) => value1.X * value2.X + value1.Y * value2.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float Dot(Vector2 value) => Vector2.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float MinComponent() => (X).Min(Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float MaxComponent() => (X).Max(Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float SumComponents() => (X) + (Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float SumSqrComponents() => (X).Sqr() + (Y).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float ProductComponents() => (X) * (Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float GetComponent(int n) => n == 0 ? X:Y;        
        public const int NumComponents = 2;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Vector3 : IEquatable< Vector3 >
    {
        [DataMember]
        public readonly float X;
        [DataMember]
        public readonly float Y;
        [DataMember]
        public readonly float Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3(float x, float y, float z) { X = x; Y = y; Z = z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Vector3 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Vector3(X = {X}, Y = {Y}, Z = {Z})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out float x, out float y, out float z) {x = X; y = Y; z = Z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Vector3 x) => X == x.X && Y == x.Y && Z == x.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Vector3 x0, Vector3 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Vector3 x0, Vector3 x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Vector3 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance);    
        public static Vector3 Zero = new Vector3(default, default, default);
        public static Vector3 MinValue = new Vector3(float.MinValue, float.MinValue, float.MinValue);
        public static Vector3 MaxValue = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3 SetX(float x) => new Vector3(x, Y, Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3 SetY(float x) => new Vector3(X, x, Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3 SetZ(float x) => new Vector3(X, Y, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator +(Vector3 value1, Vector3 value2) => new Vector3(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator +(Vector3 value1, float value2) => new Vector3(value1.X + value2,value1.Y + value2,value1.Z + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator +(float value1, Vector3 value2) => new Vector3(value1 + value2.X,value1 + value2.Y,value1 + value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator -(Vector3 value1, Vector3 value2) => new Vector3(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator -(Vector3 value1, float value2) => new Vector3(value1.X - value2,value1.Y - value2,value1.Z - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator -(float value1, Vector3 value2) => new Vector3(value1 - value2.X,value1 - value2.Y,value1 - value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator *(Vector3 value1, Vector3 value2) => new Vector3(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator *(Vector3 value1, float value2) => new Vector3(value1.X * value2,value1.Y * value2,value1.Z * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator *(float value1, Vector3 value2) => new Vector3(value1 * value2.X,value1 * value2.Y,value1 * value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator /(Vector3 value1, Vector3 value2) => new Vector3(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator /(Vector3 value1, float value2) => new Vector3(value1.X / value2,value1.Y / value2,value1.Z / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator /(float value1, Vector3 value2) => new Vector3(value1 / value2.X,value1 / value2.Y,value1 / value2.Z);
        public static Vector3 One = new Vector3(1f);
        public static Vector3 UnitX = Zero.SetX(1f);
        public static Vector3 UnitY = Zero.SetY(1f);
        public static Vector3 UnitZ = Zero.SetZ(1f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3(float value) : this(value, value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3 operator -(Vector3 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(Vector3 value1, Vector3 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float Dot(Vector3 value) => Vector3.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float MinComponent() => (X).Min(Y).Min(Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float MaxComponent() => (X).Max(Y).Max(Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float SumComponents() => (X) + (Y) + (Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float ProductComponents() => (X) * (Y) * (Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float GetComponent(int n) => n == 0 ? X : n == 1 ? Y:Z;        
        public const int NumComponents = 3;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Vector4 : IEquatable< Vector4 >
    {
        [DataMember]
        public readonly float X;
        [DataMember]
        public readonly float Y;
        [DataMember]
        public readonly float Z;
        [DataMember]
        public readonly float W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector4(float x, float y, float z, float w) { X = x; Y = y; Z = z; W = w; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Vector4 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Vector4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out float x, out float y, out float z, out float w) {x = X; y = Y; z = Z; w = W; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Vector4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Vector4 x0, Vector4 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Vector4 x0, Vector4 x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Vector4 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance) && W.AlmostEquals(x.W, tolerance);    
        public static Vector4 Zero = new Vector4(default, default, default, default);
        public static Vector4 MinValue = new Vector4(float.MinValue, float.MinValue, float.MinValue, float.MinValue);
        public static Vector4 MaxValue = new Vector4(float.MaxValue, float.MaxValue, float.MaxValue, float.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector4 SetX(float x) => new Vector4(x, Y, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector4 SetY(float x) => new Vector4(X, x, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector4 SetZ(float x) => new Vector4(X, Y, x, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector4 SetW(float x) => new Vector4(X, Y, Z, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator +(Vector4 value1, Vector4 value2) => new Vector4(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z,value1.W + value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator +(Vector4 value1, float value2) => new Vector4(value1.X + value2,value1.Y + value2,value1.Z + value2,value1.W + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator +(float value1, Vector4 value2) => new Vector4(value1 + value2.X,value1 + value2.Y,value1 + value2.Z,value1 + value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator -(Vector4 value1, Vector4 value2) => new Vector4(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z,value1.W - value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator -(Vector4 value1, float value2) => new Vector4(value1.X - value2,value1.Y - value2,value1.Z - value2,value1.W - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator -(float value1, Vector4 value2) => new Vector4(value1 - value2.X,value1 - value2.Y,value1 - value2.Z,value1 - value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator *(Vector4 value1, Vector4 value2) => new Vector4(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z,value1.W * value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator *(Vector4 value1, float value2) => new Vector4(value1.X * value2,value1.Y * value2,value1.Z * value2,value1.W * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator *(float value1, Vector4 value2) => new Vector4(value1 * value2.X,value1 * value2.Y,value1 * value2.Z,value1 * value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator /(Vector4 value1, Vector4 value2) => new Vector4(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z,value1.W / value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator /(Vector4 value1, float value2) => new Vector4(value1.X / value2,value1.Y / value2,value1.Z / value2,value1.W / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator /(float value1, Vector4 value2) => new Vector4(value1 / value2.X,value1 / value2.Y,value1 / value2.Z,value1 / value2.W);
        public static Vector4 One = new Vector4(1f);
        public static Vector4 UnitX = Zero.SetX(1f);
        public static Vector4 UnitY = Zero.SetY(1f);
        public static Vector4 UnitZ = Zero.SetZ(1f);
        public static Vector4 UnitW = Zero.SetW(1f);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector4(float value) : this(value, value, value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector4 operator -(Vector4 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Dot(Vector4 value1, Vector4 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z + value1.W * value2.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float Dot(Vector4 value) => Vector4.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance && W.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN() || W.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity() || W.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float MinComponent() => (X).Min(Y).Min(Z).Min(W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float MaxComponent() => (X).Max(Y).Max(Z).Max(W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float SumComponents() => (X) + (Y) + (Z) + (W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr() + (W).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float ProductComponents() => (X) * (Y) * (Z) * (W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public float GetComponent(int n) => n == 0 ? X : n == 1 ? Y : n == 2 ? Z:W;        
        public const int NumComponents = 4;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DVector2 : IEquatable< DVector2 >
    {
        [DataMember]
        public readonly double X;
        [DataMember]
        public readonly double Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector2(double x, double y) { X = x; Y = y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DVector2 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DVector2(X = {X}, Y = {Y})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out double x, out double y) {x = X; y = Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DVector2 x) => X == x.X && Y == x.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DVector2 x0, DVector2 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DVector2 x0, DVector2 x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DVector2 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance);    
        public static DVector2 Zero = new DVector2(default, default);
        public static DVector2 MinValue = new DVector2(double.MinValue, double.MinValue);
        public static DVector2 MaxValue = new DVector2(double.MaxValue, double.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector2 SetX(double x) => new DVector2(x, Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector2 SetY(double x) => new DVector2(X, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator +(DVector2 value1, DVector2 value2) => new DVector2(value1.X + value2.X,value1.Y + value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator +(DVector2 value1, double value2) => new DVector2(value1.X + value2,value1.Y + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator +(double value1, DVector2 value2) => new DVector2(value1 + value2.X,value1 + value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator -(DVector2 value1, DVector2 value2) => new DVector2(value1.X - value2.X,value1.Y - value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator -(DVector2 value1, double value2) => new DVector2(value1.X - value2,value1.Y - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator -(double value1, DVector2 value2) => new DVector2(value1 - value2.X,value1 - value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator *(DVector2 value1, DVector2 value2) => new DVector2(value1.X * value2.X,value1.Y * value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator *(DVector2 value1, double value2) => new DVector2(value1.X * value2,value1.Y * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator *(double value1, DVector2 value2) => new DVector2(value1 * value2.X,value1 * value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator /(DVector2 value1, DVector2 value2) => new DVector2(value1.X / value2.X,value1.Y / value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator /(DVector2 value1, double value2) => new DVector2(value1.X / value2,value1.Y / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator /(double value1, DVector2 value2) => new DVector2(value1 / value2.X,value1 / value2.Y);
        public static DVector2 One = new DVector2(1.0);
        public static DVector2 UnitX = Zero.SetX(1.0);
        public static DVector2 UnitY = Zero.SetY(1.0);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector2(double value) : this(value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector2 operator -(DVector2 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(DVector2 value1, DVector2 value2) => value1.X * value2.X + value1.Y * value2.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double Dot(DVector2 value) => DVector2.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double MinComponent() => (X).Min(Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double MaxComponent() => (X).Max(Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double SumComponents() => (X) + (Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double SumSqrComponents() => (X).Sqr() + (Y).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double ProductComponents() => (X) * (Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double GetComponent(int n) => n == 0 ? X:Y;        
        public const int NumComponents = 2;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DVector3 : IEquatable< DVector3 >
    {
        [DataMember]
        public readonly double X;
        [DataMember]
        public readonly double Y;
        [DataMember]
        public readonly double Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector3(double x, double y, double z) { X = x; Y = y; Z = z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DVector3 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DVector3(X = {X}, Y = {Y}, Z = {Z})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out double x, out double y, out double z) {x = X; y = Y; z = Z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DVector3 x) => X == x.X && Y == x.Y && Z == x.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DVector3 x0, DVector3 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DVector3 x0, DVector3 x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DVector3 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance);    
        public static DVector3 Zero = new DVector3(default, default, default);
        public static DVector3 MinValue = new DVector3(double.MinValue, double.MinValue, double.MinValue);
        public static DVector3 MaxValue = new DVector3(double.MaxValue, double.MaxValue, double.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector3 SetX(double x) => new DVector3(x, Y, Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector3 SetY(double x) => new DVector3(X, x, Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector3 SetZ(double x) => new DVector3(X, Y, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator +(DVector3 value1, DVector3 value2) => new DVector3(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator +(DVector3 value1, double value2) => new DVector3(value1.X + value2,value1.Y + value2,value1.Z + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator +(double value1, DVector3 value2) => new DVector3(value1 + value2.X,value1 + value2.Y,value1 + value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator -(DVector3 value1, DVector3 value2) => new DVector3(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator -(DVector3 value1, double value2) => new DVector3(value1.X - value2,value1.Y - value2,value1.Z - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator -(double value1, DVector3 value2) => new DVector3(value1 - value2.X,value1 - value2.Y,value1 - value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator *(DVector3 value1, DVector3 value2) => new DVector3(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator *(DVector3 value1, double value2) => new DVector3(value1.X * value2,value1.Y * value2,value1.Z * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator *(double value1, DVector3 value2) => new DVector3(value1 * value2.X,value1 * value2.Y,value1 * value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator /(DVector3 value1, DVector3 value2) => new DVector3(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator /(DVector3 value1, double value2) => new DVector3(value1.X / value2,value1.Y / value2,value1.Z / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator /(double value1, DVector3 value2) => new DVector3(value1 / value2.X,value1 / value2.Y,value1 / value2.Z);
        public static DVector3 One = new DVector3(1.0);
        public static DVector3 UnitX = Zero.SetX(1.0);
        public static DVector3 UnitY = Zero.SetY(1.0);
        public static DVector3 UnitZ = Zero.SetZ(1.0);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector3(double value) : this(value, value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector3 operator -(DVector3 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(DVector3 value1, DVector3 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double Dot(DVector3 value) => DVector3.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double MinComponent() => (X).Min(Y).Min(Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double MaxComponent() => (X).Max(Y).Max(Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double SumComponents() => (X) + (Y) + (Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double ProductComponents() => (X) * (Y) * (Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double GetComponent(int n) => n == 0 ? X : n == 1 ? Y:Z;        
        public const int NumComponents = 3;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DVector4 : IEquatable< DVector4 >
    {
        [DataMember]
        public readonly double X;
        [DataMember]
        public readonly double Y;
        [DataMember]
        public readonly double Z;
        [DataMember]
        public readonly double W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector4(double x, double y, double z, double w) { X = x; Y = y; Z = z; W = w; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DVector4 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DVector4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out double x, out double y, out double z, out double w) {x = X; y = Y; z = Z; w = W; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DVector4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DVector4 x0, DVector4 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DVector4 x0, DVector4 x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DVector4 x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance) && W.AlmostEquals(x.W, tolerance);    
        public static DVector4 Zero = new DVector4(default, default, default, default);
        public static DVector4 MinValue = new DVector4(double.MinValue, double.MinValue, double.MinValue, double.MinValue);
        public static DVector4 MaxValue = new DVector4(double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector4 SetX(double x) => new DVector4(x, Y, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector4 SetY(double x) => new DVector4(X, x, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector4 SetZ(double x) => new DVector4(X, Y, x, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector4 SetW(double x) => new DVector4(X, Y, Z, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator +(DVector4 value1, DVector4 value2) => new DVector4(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z,value1.W + value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator +(DVector4 value1, double value2) => new DVector4(value1.X + value2,value1.Y + value2,value1.Z + value2,value1.W + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator +(double value1, DVector4 value2) => new DVector4(value1 + value2.X,value1 + value2.Y,value1 + value2.Z,value1 + value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator -(DVector4 value1, DVector4 value2) => new DVector4(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z,value1.W - value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator -(DVector4 value1, double value2) => new DVector4(value1.X - value2,value1.Y - value2,value1.Z - value2,value1.W - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator -(double value1, DVector4 value2) => new DVector4(value1 - value2.X,value1 - value2.Y,value1 - value2.Z,value1 - value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator *(DVector4 value1, DVector4 value2) => new DVector4(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z,value1.W * value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator *(DVector4 value1, double value2) => new DVector4(value1.X * value2,value1.Y * value2,value1.Z * value2,value1.W * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator *(double value1, DVector4 value2) => new DVector4(value1 * value2.X,value1 * value2.Y,value1 * value2.Z,value1 * value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator /(DVector4 value1, DVector4 value2) => new DVector4(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z,value1.W / value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator /(DVector4 value1, double value2) => new DVector4(value1.X / value2,value1.Y / value2,value1.Z / value2,value1.W / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator /(double value1, DVector4 value2) => new DVector4(value1 / value2.X,value1 / value2.Y,value1 / value2.Z,value1 / value2.W);
        public static DVector4 One = new DVector4(1.0);
        public static DVector4 UnitX = Zero.SetX(1.0);
        public static DVector4 UnitY = Zero.SetY(1.0);
        public static DVector4 UnitZ = Zero.SetZ(1.0);
        public static DVector4 UnitW = Zero.SetW(1.0);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DVector4(double value) : this(value, value, value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static DVector4 operator -(DVector4 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(DVector4 value1, DVector4 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z + value1.W * value2.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double Dot(DVector4 value) => DVector4.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance && W.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN() || W.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity() || W.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double MinComponent() => (X).Min(Y).Min(Z).Min(W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double MaxComponent() => (X).Max(Y).Max(Z).Max(W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double SumComponents() => (X) + (Y) + (Z) + (W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr() + (W).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double ProductComponents() => (X) * (Y) * (Z) * (W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public double GetComponent(int n) => n == 0 ? X : n == 1 ? Y : n == 2 ? Z:W;        
        public const int NumComponents = 4;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Plane : IEquatable< Plane >
    {
        [DataMember]
        public readonly Vector3 Normal;
        [DataMember]
        public readonly float D;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Plane(Vector3 normal, float d) { Normal = normal; D = d; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Plane x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Normal.GetHashCode(), D.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Plane(Normal = {Normal}, D = {D})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector3 normal, out float d) {normal = Normal; d = D; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Plane x) => Normal == x.Normal && D == x.D;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Plane x0, Plane x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Plane x0, Plane x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Plane x, float tolerance = Constants.Tolerance) => Normal.AlmostEquals(x.Normal, tolerance) && D.AlmostEquals(x.D, tolerance);    
        public static Plane Zero = new Plane(default, default);
        public static Plane MinValue = new Plane(Vector3.MinValue, float.MinValue);
        public static Plane MaxValue = new Plane(Vector3.MaxValue, float.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Plane SetNormal(Vector3 x) => new Plane(x, D);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Plane SetD(float x) => new Plane(Normal, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DPlane : IEquatable< DPlane >
    {
        [DataMember]
        public readonly DVector3 Normal;
        [DataMember]
        public readonly double D;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DPlane(DVector3 normal, double d) { Normal = normal; D = d; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DPlane x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Normal.GetHashCode(), D.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DPlane(Normal = {Normal}, D = {D})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out DVector3 normal, out double d) {normal = Normal; d = D; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DPlane x) => Normal == x.Normal && D == x.D;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DPlane x0, DPlane x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DPlane x0, DPlane x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DPlane x, float tolerance = Constants.Tolerance) => Normal.AlmostEquals(x.Normal, tolerance) && D.AlmostEquals(x.D, tolerance);    
        public static DPlane Zero = new DPlane(default, default);
        public static DPlane MinValue = new DPlane(DVector3.MinValue, double.MinValue);
        public static DPlane MaxValue = new DPlane(DVector3.MaxValue, double.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DPlane SetNormal(DVector3 x) => new DPlane(x, D);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DPlane SetD(double x) => new DPlane(Normal, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Quaternion : IEquatable< Quaternion >
    {
        [DataMember]
        public readonly float X;
        [DataMember]
        public readonly float Y;
        [DataMember]
        public readonly float Z;
        [DataMember]
        public readonly float W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quaternion(float x, float y, float z, float w) { X = x; Y = y; Z = z; W = w; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Quaternion x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Quaternion(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out float x, out float y, out float z, out float w) {x = X; y = Y; z = Z; w = W; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Quaternion x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Quaternion x0, Quaternion x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Quaternion x0, Quaternion x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Quaternion x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance) && W.AlmostEquals(x.W, tolerance);    
        public static Quaternion Zero = new Quaternion(default, default, default, default);
        public static Quaternion MinValue = new Quaternion(float.MinValue, float.MinValue, float.MinValue, float.MinValue);
        public static Quaternion MaxValue = new Quaternion(float.MaxValue, float.MaxValue, float.MaxValue, float.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quaternion SetX(float x) => new Quaternion(x, Y, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quaternion SetY(float x) => new Quaternion(X, x, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quaternion SetZ(float x) => new Quaternion(X, Y, x, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quaternion SetW(float x) => new Quaternion(X, Y, Z, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DQuaternion : IEquatable< DQuaternion >
    {
        [DataMember]
        public readonly double X;
        [DataMember]
        public readonly double Y;
        [DataMember]
        public readonly double Z;
        [DataMember]
        public readonly double W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DQuaternion(double x, double y, double z, double w) { X = x; Y = y; Z = z; W = w; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DQuaternion x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DQuaternion(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out double x, out double y, out double z, out double w) {x = X; y = Y; z = Z; w = W; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DQuaternion x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DQuaternion x0, DQuaternion x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DQuaternion x0, DQuaternion x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DQuaternion x, float tolerance = Constants.Tolerance) => X.AlmostEquals(x.X, tolerance) && Y.AlmostEquals(x.Y, tolerance) && Z.AlmostEquals(x.Z, tolerance) && W.AlmostEquals(x.W, tolerance);    
        public static DQuaternion Zero = new DQuaternion(default, default, default, default);
        public static DQuaternion MinValue = new DQuaternion(double.MinValue, double.MinValue, double.MinValue, double.MinValue);
        public static DQuaternion MaxValue = new DQuaternion(double.MaxValue, double.MaxValue, double.MaxValue, double.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DQuaternion SetX(double x) => new DQuaternion(x, Y, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DQuaternion SetY(double x) => new DQuaternion(X, x, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DQuaternion SetZ(double x) => new DQuaternion(X, Y, x, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DQuaternion SetW(double x) => new DQuaternion(X, Y, Z, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Interval : IEquatable< Interval >
    {
        [DataMember]
        public readonly float Min;
        [DataMember]
        public readonly float Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Interval(float min, float max) { Min = min; Max = max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Interval x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Interval(Min = {Min}, Max = {Max})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out float min, out float max) {min = Min; max = Max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Interval x) => Min == x.Min && Max == x.Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Interval x0, Interval x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Interval x0, Interval x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Interval x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);    
        public static Interval Zero = new Interval(default, default);
        public static Interval MinValue = new Interval(float.MinValue, float.MinValue);
        public static Interval MaxValue = new Interval(float.MaxValue, float.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Interval SetMin(float x) => new Interval(x, Max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Interval SetMax(float x) => new Interval(Min, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct AABox2D : IEquatable< AABox2D >
    {
        [DataMember]
        public readonly Vector2 Min;
        [DataMember]
        public readonly Vector2 Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox2D(Vector2 min, Vector2 max) { Min = min; Max = max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is AABox2D x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"AABox2D(Min = {Min}, Max = {Max})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector2 min, out Vector2 max) {min = Min; max = Max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(AABox2D x) => Min == x.Min && Max == x.Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(AABox2D x0, AABox2D x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(AABox2D x0, AABox2D x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(AABox2D x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);    
        public static AABox2D Zero = new AABox2D(default, default);
        public static AABox2D MinValue = new AABox2D(Vector2.MinValue, Vector2.MinValue);
        public static AABox2D MaxValue = new AABox2D(Vector2.MaxValue, Vector2.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox2D SetMin(Vector2 x) => new AABox2D(x, Max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox2D SetMax(Vector2 x) => new AABox2D(Min, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct AABox : IEquatable< AABox >
    {
        [DataMember]
        public readonly Vector3 Min;
        [DataMember]
        public readonly Vector3 Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox(Vector3 min, Vector3 max) { Min = min; Max = max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is AABox x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"AABox(Min = {Min}, Max = {Max})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector3 min, out Vector3 max) {min = Min; max = Max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(AABox x) => Min == x.Min && Max == x.Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(AABox x0, AABox x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(AABox x0, AABox x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(AABox x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);    
        public static AABox Zero = new AABox(default, default);
        public static AABox MinValue = new AABox(Vector3.MinValue, Vector3.MinValue);
        public static AABox MaxValue = new AABox(Vector3.MaxValue, Vector3.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox SetMin(Vector3 x) => new AABox(x, Max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox SetMax(Vector3 x) => new AABox(Min, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct AABox4D : IEquatable< AABox4D >
    {
        [DataMember]
        public readonly Vector4 Min;
        [DataMember]
        public readonly Vector4 Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox4D(Vector4 min, Vector4 max) { Min = min; Max = max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is AABox4D x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"AABox4D(Min = {Min}, Max = {Max})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector4 min, out Vector4 max) {min = Min; max = Max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(AABox4D x) => Min == x.Min && Max == x.Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(AABox4D x0, AABox4D x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(AABox4D x0, AABox4D x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(AABox4D x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);    
        public static AABox4D Zero = new AABox4D(default, default);
        public static AABox4D MinValue = new AABox4D(Vector4.MinValue, Vector4.MinValue);
        public static AABox4D MaxValue = new AABox4D(Vector4.MaxValue, Vector4.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox4D SetMin(Vector4 x) => new AABox4D(x, Max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public AABox4D SetMax(Vector4 x) => new AABox4D(Min, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DInterval : IEquatable< DInterval >
    {
        [DataMember]
        public readonly double Min;
        [DataMember]
        public readonly double Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DInterval(double min, double max) { Min = min; Max = max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DInterval x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DInterval(Min = {Min}, Max = {Max})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out double min, out double max) {min = Min; max = Max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DInterval x) => Min == x.Min && Max == x.Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DInterval x0, DInterval x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DInterval x0, DInterval x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DInterval x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);    
        public static DInterval Zero = new DInterval(default, default);
        public static DInterval MinValue = new DInterval(double.MinValue, double.MinValue);
        public static DInterval MaxValue = new DInterval(double.MaxValue, double.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DInterval SetMin(double x) => new DInterval(x, Max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DInterval SetMax(double x) => new DInterval(Min, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DAABox2D : IEquatable< DAABox2D >
    {
        [DataMember]
        public readonly DVector2 Min;
        [DataMember]
        public readonly DVector2 Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox2D(DVector2 min, DVector2 max) { Min = min; Max = max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DAABox2D x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DAABox2D(Min = {Min}, Max = {Max})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out DVector2 min, out DVector2 max) {min = Min; max = Max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DAABox2D x) => Min == x.Min && Max == x.Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DAABox2D x0, DAABox2D x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DAABox2D x0, DAABox2D x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DAABox2D x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);    
        public static DAABox2D Zero = new DAABox2D(default, default);
        public static DAABox2D MinValue = new DAABox2D(DVector2.MinValue, DVector2.MinValue);
        public static DAABox2D MaxValue = new DAABox2D(DVector2.MaxValue, DVector2.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox2D SetMin(DVector2 x) => new DAABox2D(x, Max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox2D SetMax(DVector2 x) => new DAABox2D(Min, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DAABox : IEquatable< DAABox >
    {
        [DataMember]
        public readonly DVector3 Min;
        [DataMember]
        public readonly DVector3 Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox(DVector3 min, DVector3 max) { Min = min; Max = max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DAABox x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DAABox(Min = {Min}, Max = {Max})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out DVector3 min, out DVector3 max) {min = Min; max = Max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DAABox x) => Min == x.Min && Max == x.Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DAABox x0, DAABox x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DAABox x0, DAABox x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DAABox x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);    
        public static DAABox Zero = new DAABox(default, default);
        public static DAABox MinValue = new DAABox(DVector3.MinValue, DVector3.MinValue);
        public static DAABox MaxValue = new DAABox(DVector3.MaxValue, DVector3.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox SetMin(DVector3 x) => new DAABox(x, Max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox SetMax(DVector3 x) => new DAABox(Min, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DAABox4D : IEquatable< DAABox4D >
    {
        [DataMember]
        public readonly DVector4 Min;
        [DataMember]
        public readonly DVector4 Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox4D(DVector4 min, DVector4 max) { Min = min; Max = max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DAABox4D x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DAABox4D(Min = {Min}, Max = {Max})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out DVector4 min, out DVector4 max) {min = Min; max = Max; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DAABox4D x) => Min == x.Min && Max == x.Max;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DAABox4D x0, DAABox4D x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DAABox4D x0, DAABox4D x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DAABox4D x, float tolerance = Constants.Tolerance) => Min.AlmostEquals(x.Min, tolerance) && Max.AlmostEquals(x.Max, tolerance);    
        public static DAABox4D Zero = new DAABox4D(default, default);
        public static DAABox4D MinValue = new DAABox4D(DVector4.MinValue, DVector4.MinValue);
        public static DAABox4D MaxValue = new DAABox4D(DVector4.MaxValue, DVector4.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox4D SetMin(DVector4 x) => new DAABox4D(x, Max);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DAABox4D SetMax(DVector4 x) => new DAABox4D(Min, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Ray : IEquatable< Ray >
    {
        [DataMember]
        public readonly Vector3 Position;
        [DataMember]
        public readonly Vector3 Direction;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Ray(Vector3 position, Vector3 direction) { Position = position; Direction = direction; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Ray x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Ray(Position = {Position}, Direction = {Direction})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector3 position, out Vector3 direction) {position = Position; direction = Direction; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Ray x) => Position == x.Position && Direction == x.Direction;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Ray x0, Ray x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Ray x0, Ray x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Ray x, float tolerance = Constants.Tolerance) => Position.AlmostEquals(x.Position, tolerance) && Direction.AlmostEquals(x.Direction, tolerance);    
        public static Ray Zero = new Ray(default, default);
        public static Ray MinValue = new Ray(Vector3.MinValue, Vector3.MinValue);
        public static Ray MaxValue = new Ray(Vector3.MaxValue, Vector3.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Ray SetPosition(Vector3 x) => new Ray(x, Direction);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Ray SetDirection(Vector3 x) => new Ray(Position, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DRay : IEquatable< DRay >
    {
        [DataMember]
        public readonly DVector3 Position;
        [DataMember]
        public readonly DVector3 Direction;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DRay(DVector3 position, DVector3 direction) { Position = position; Direction = direction; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DRay x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DRay(Position = {Position}, Direction = {Direction})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out DVector3 position, out DVector3 direction) {position = Position; direction = Direction; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DRay x) => Position == x.Position && Direction == x.Direction;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DRay x0, DRay x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DRay x0, DRay x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DRay x, float tolerance = Constants.Tolerance) => Position.AlmostEquals(x.Position, tolerance) && Direction.AlmostEquals(x.Direction, tolerance);    
        public static DRay Zero = new DRay(default, default);
        public static DRay MinValue = new DRay(DVector3.MinValue, DVector3.MinValue);
        public static DRay MaxValue = new DRay(DVector3.MaxValue, DVector3.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DRay SetPosition(DVector3 x) => new DRay(x, Direction);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DRay SetDirection(DVector3 x) => new DRay(Position, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Sphere : IEquatable< Sphere >
    {
        [DataMember]
        public readonly Vector3 Center;
        [DataMember]
        public readonly float Radius;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Sphere(Vector3 center, float radius) { Center = center; Radius = radius; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Sphere x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Center.GetHashCode(), Radius.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Sphere(Center = {Center}, Radius = {Radius})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector3 center, out float radius) {center = Center; radius = Radius; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Sphere x) => Center == x.Center && Radius == x.Radius;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Sphere x0, Sphere x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Sphere x0, Sphere x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Sphere x, float tolerance = Constants.Tolerance) => Center.AlmostEquals(x.Center, tolerance) && Radius.AlmostEquals(x.Radius, tolerance);    
        public static Sphere Zero = new Sphere(default, default);
        public static Sphere MinValue = new Sphere(Vector3.MinValue, float.MinValue);
        public static Sphere MaxValue = new Sphere(Vector3.MaxValue, float.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Sphere SetCenter(Vector3 x) => new Sphere(x, Radius);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Sphere SetRadius(float x) => new Sphere(Center, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct DSphere : IEquatable< DSphere >
    {
        [DataMember]
        public readonly DVector3 Center;
        [DataMember]
        public readonly double Radius;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DSphere(DVector3 center, double radius) { Center = center; Radius = radius; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is DSphere x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(Center.GetHashCode(), Radius.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"DSphere(Center = {Center}, Radius = {Radius})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out DVector3 center, out double radius) {center = Center; radius = Radius; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(DSphere x) => Center == x.Center && Radius == x.Radius;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(DSphere x0, DSphere x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(DSphere x0, DSphere x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(DSphere x, float tolerance = Constants.Tolerance) => Center.AlmostEquals(x.Center, tolerance) && Radius.AlmostEquals(x.Radius, tolerance);    
        public static DSphere Zero = new DSphere(default, default);
        public static DSphere MinValue = new DSphere(DVector3.MinValue, double.MinValue);
        public static DSphere MaxValue = new DSphere(DVector3.MaxValue, double.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DSphere SetCenter(DVector3 x) => new DSphere(x, Radius);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public DSphere SetRadius(double x) => new DSphere(Center, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Line : IEquatable< Line >
    {
        [DataMember]
        public readonly Vector3 A;
        [DataMember]
        public readonly Vector3 B;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Line(Vector3 a, Vector3 b) { A = a; B = b; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Line x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Line(A = {A}, B = {B})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector3 a, out Vector3 b) {a = A; b = B; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Line x) => A == x.A && B == x.B;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Line x0, Line x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Line x0, Line x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Line x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance);    
        public static Line Zero = new Line(default, default);
        public static Line MinValue = new Line(Vector3.MinValue, Vector3.MinValue);
        public static Line MaxValue = new Line(Vector3.MaxValue, Vector3.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Line SetA(Vector3 x) => new Line(x, B);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Line SetB(Vector3 x) => new Line(A, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Line2D : IEquatable< Line2D >
    {
        [DataMember]
        public readonly Vector2 A;
        [DataMember]
        public readonly Vector2 B;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Line2D(Vector2 a, Vector2 b) { A = a; B = b; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Line2D x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Line2D(A = {A}, B = {B})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector2 a, out Vector2 b) {a = A; b = B; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Line2D x) => A == x.A && B == x.B;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Line2D x0, Line2D x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Line2D x0, Line2D x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Line2D x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance);    
        public static Line2D Zero = new Line2D(default, default);
        public static Line2D MinValue = new Line2D(Vector2.MinValue, Vector2.MinValue);
        public static Line2D MaxValue = new Line2D(Vector2.MaxValue, Vector2.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Line2D SetA(Vector2 x) => new Line2D(x, B);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Line2D SetB(Vector2 x) => new Line2D(A, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Triangle : IEquatable< Triangle >
    {
        [DataMember]
        public readonly Vector3 A;
        [DataMember]
        public readonly Vector3 B;
        [DataMember]
        public readonly Vector3 C;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Triangle(Vector3 a, Vector3 b, Vector3 c) { A = a; B = b; C = c; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Triangle x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Triangle(A = {A}, B = {B}, C = {C})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector3 a, out Vector3 b, out Vector3 c) {a = A; b = B; c = C; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Triangle x) => A == x.A && B == x.B && C == x.C;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Triangle x0, Triangle x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Triangle x0, Triangle x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Triangle x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance) && C.AlmostEquals(x.C, tolerance);    
        public static Triangle Zero = new Triangle(default, default, default);
        public static Triangle MinValue = new Triangle(Vector3.MinValue, Vector3.MinValue, Vector3.MinValue);
        public static Triangle MaxValue = new Triangle(Vector3.MaxValue, Vector3.MaxValue, Vector3.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Triangle SetA(Vector3 x) => new Triangle(x, B, C);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Triangle SetB(Vector3 x) => new Triangle(A, x, C);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Triangle SetC(Vector3 x) => new Triangle(A, B, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Triangle2D : IEquatable< Triangle2D >
    {
        [DataMember]
        public readonly Vector2 A;
        [DataMember]
        public readonly Vector2 B;
        [DataMember]
        public readonly Vector2 C;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Triangle2D(Vector2 a, Vector2 b, Vector2 c) { A = a; B = b; C = c; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Triangle2D x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Triangle2D(A = {A}, B = {B}, C = {C})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector2 a, out Vector2 b, out Vector2 c) {a = A; b = B; c = C; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Triangle2D x) => A == x.A && B == x.B && C == x.C;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Triangle2D x0, Triangle2D x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Triangle2D x0, Triangle2D x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Triangle2D x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance) && C.AlmostEquals(x.C, tolerance);    
        public static Triangle2D Zero = new Triangle2D(default, default, default);
        public static Triangle2D MinValue = new Triangle2D(Vector2.MinValue, Vector2.MinValue, Vector2.MinValue);
        public static Triangle2D MaxValue = new Triangle2D(Vector2.MaxValue, Vector2.MaxValue, Vector2.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Triangle2D SetA(Vector2 x) => new Triangle2D(x, B, C);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Triangle2D SetB(Vector2 x) => new Triangle2D(A, x, C);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Triangle2D SetC(Vector2 x) => new Triangle2D(A, B, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Quad : IEquatable< Quad >
    {
        [DataMember]
        public readonly Vector3 A;
        [DataMember]
        public readonly Vector3 B;
        [DataMember]
        public readonly Vector3 C;
        [DataMember]
        public readonly Vector3 D;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad(Vector3 a, Vector3 b, Vector3 c, Vector3 d) { A = a; B = b; C = c; D = d; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Quad x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode(), D.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Quad(A = {A}, B = {B}, C = {C}, D = {D})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector3 a, out Vector3 b, out Vector3 c, out Vector3 d) {a = A; b = B; c = C; d = D; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Quad x) => A == x.A && B == x.B && C == x.C && D == x.D;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Quad x0, Quad x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Quad x0, Quad x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Quad x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance) && C.AlmostEquals(x.C, tolerance) && D.AlmostEquals(x.D, tolerance);    
        public static Quad Zero = new Quad(default, default, default, default);
        public static Quad MinValue = new Quad(Vector3.MinValue, Vector3.MinValue, Vector3.MinValue, Vector3.MinValue);
        public static Quad MaxValue = new Quad(Vector3.MaxValue, Vector3.MaxValue, Vector3.MaxValue, Vector3.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad SetA(Vector3 x) => new Quad(x, B, C, D);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad SetB(Vector3 x) => new Quad(A, x, C, D);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad SetC(Vector3 x) => new Quad(A, B, x, D);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad SetD(Vector3 x) => new Quad(A, B, C, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Quad2D : IEquatable< Quad2D >
    {
        [DataMember]
        public readonly Vector2 A;
        [DataMember]
        public readonly Vector2 B;
        [DataMember]
        public readonly Vector2 C;
        [DataMember]
        public readonly Vector2 D;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad2D(Vector2 a, Vector2 b, Vector2 c, Vector2 d) { A = a; B = b; C = c; D = d; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Quad2D x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode(), D.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Quad2D(A = {A}, B = {B}, C = {C}, D = {D})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out Vector2 a, out Vector2 b, out Vector2 c, out Vector2 d) {a = A; b = B; c = C; d = D; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Quad2D x) => A == x.A && B == x.B && C == x.C && D == x.D;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Quad2D x0, Quad2D x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Quad2D x0, Quad2D x1) => !x0.Equals(x1);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostEquals(Quad2D x, float tolerance = Constants.Tolerance) => A.AlmostEquals(x.A, tolerance) && B.AlmostEquals(x.B, tolerance) && C.AlmostEquals(x.C, tolerance) && D.AlmostEquals(x.D, tolerance);    
        public static Quad2D Zero = new Quad2D(default, default, default, default);
        public static Quad2D MinValue = new Quad2D(Vector2.MinValue, Vector2.MinValue, Vector2.MinValue, Vector2.MinValue);
        public static Quad2D MaxValue = new Quad2D(Vector2.MaxValue, Vector2.MaxValue, Vector2.MaxValue, Vector2.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad2D SetA(Vector2 x) => new Quad2D(x, B, C, D);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad2D SetB(Vector2 x) => new Quad2D(A, x, C, D);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad2D SetC(Vector2 x) => new Quad2D(A, B, x, D);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Quad2D SetD(Vector2 x) => new Quad2D(A, B, C, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Int2 : IEquatable< Int2 >
    {
        [DataMember]
        public readonly int X;
        [DataMember]
        public readonly int Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int2(int x, int y) { X = x; Y = y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Int2 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Int2(X = {X}, Y = {Y})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out int x, out int y) {x = X; y = Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Int2 x) => X == x.X && Y == x.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Int2 x0, Int2 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Int2 x0, Int2 x1) => !x0.Equals(x1);

        public static Int2 Zero = new Int2(default, default);
        public static Int2 MinValue = new Int2(int.MinValue, int.MinValue);
        public static Int2 MaxValue = new Int2(int.MaxValue, int.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int2 SetX(int x) => new Int2(x, Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int2 SetY(int x) => new Int2(X, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator +(Int2 value1, Int2 value2) => new Int2(value1.X + value2.X,value1.Y + value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator +(Int2 value1, int value2) => new Int2(value1.X + value2,value1.Y + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator +(int value1, Int2 value2) => new Int2(value1 + value2.X,value1 + value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator -(Int2 value1, Int2 value2) => new Int2(value1.X - value2.X,value1.Y - value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator -(Int2 value1, int value2) => new Int2(value1.X - value2,value1.Y - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator -(int value1, Int2 value2) => new Int2(value1 - value2.X,value1 - value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator *(Int2 value1, Int2 value2) => new Int2(value1.X * value2.X,value1.Y * value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator *(Int2 value1, int value2) => new Int2(value1.X * value2,value1.Y * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator *(int value1, Int2 value2) => new Int2(value1 * value2.X,value1 * value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator /(Int2 value1, Int2 value2) => new Int2(value1.X / value2.X,value1.Y / value2.Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator /(Int2 value1, int value2) => new Int2(value1.X / value2,value1.Y / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator /(int value1, Int2 value2) => new Int2(value1 / value2.X,value1 / value2.Y);
        public static Int2 One = new Int2(1);
        public static Int2 UnitX = Zero.SetX(1);
        public static Int2 UnitY = Zero.SetY(1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int2(int value) : this(value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int2 operator -(Int2 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Dot(Int2 value1, Int2 value2) => value1.X * value2.X + value1.Y * value2.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int Dot(Int2 value) => Int2.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int MinComponent() => (X).Min(Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int MaxComponent() => (X).Max(Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int SumComponents() => (X) + (Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int SumSqrComponents() => (X).Sqr() + (Y).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int ProductComponents() => (X) * (Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int GetComponent(int n) => n == 0 ? X:Y;        
        public const int NumComponents = 2;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Int3 : IEquatable< Int3 >
    {
        [DataMember]
        public readonly int X;
        [DataMember]
        public readonly int Y;
        [DataMember]
        public readonly int Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int3(int x, int y, int z) { X = x; Y = y; Z = z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Int3 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Int3(X = {X}, Y = {Y}, Z = {Z})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out int x, out int y, out int z) {x = X; y = Y; z = Z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Int3 x) => X == x.X && Y == x.Y && Z == x.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Int3 x0, Int3 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Int3 x0, Int3 x1) => !x0.Equals(x1);

        public static Int3 Zero = new Int3(default, default, default);
        public static Int3 MinValue = new Int3(int.MinValue, int.MinValue, int.MinValue);
        public static Int3 MaxValue = new Int3(int.MaxValue, int.MaxValue, int.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int3 SetX(int x) => new Int3(x, Y, Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int3 SetY(int x) => new Int3(X, x, Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int3 SetZ(int x) => new Int3(X, Y, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator +(Int3 value1, Int3 value2) => new Int3(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator +(Int3 value1, int value2) => new Int3(value1.X + value2,value1.Y + value2,value1.Z + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator +(int value1, Int3 value2) => new Int3(value1 + value2.X,value1 + value2.Y,value1 + value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator -(Int3 value1, Int3 value2) => new Int3(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator -(Int3 value1, int value2) => new Int3(value1.X - value2,value1.Y - value2,value1.Z - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator -(int value1, Int3 value2) => new Int3(value1 - value2.X,value1 - value2.Y,value1 - value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator *(Int3 value1, Int3 value2) => new Int3(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator *(Int3 value1, int value2) => new Int3(value1.X * value2,value1.Y * value2,value1.Z * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator *(int value1, Int3 value2) => new Int3(value1 * value2.X,value1 * value2.Y,value1 * value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator /(Int3 value1, Int3 value2) => new Int3(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator /(Int3 value1, int value2) => new Int3(value1.X / value2,value1.Y / value2,value1.Z / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator /(int value1, Int3 value2) => new Int3(value1 / value2.X,value1 / value2.Y,value1 / value2.Z);
        public static Int3 One = new Int3(1);
        public static Int3 UnitX = Zero.SetX(1);
        public static Int3 UnitY = Zero.SetY(1);
        public static Int3 UnitZ = Zero.SetZ(1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int3(int value) : this(value, value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int3 operator -(Int3 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Dot(Int3 value1, Int3 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int Dot(Int3 value) => Int3.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int MinComponent() => (X).Min(Y).Min(Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int MaxComponent() => (X).Max(Y).Max(Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int SumComponents() => (X) + (Y) + (Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int ProductComponents() => (X) * (Y) * (Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int GetComponent(int n) => n == 0 ? X : n == 1 ? Y:Z;        
        public const int NumComponents = 3;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Int4 : IEquatable< Int4 >
    {
        [DataMember]
        public readonly int X;
        [DataMember]
        public readonly int Y;
        [DataMember]
        public readonly int Z;
        [DataMember]
        public readonly int W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int4(int x, int y, int z, int w) { X = x; Y = y; Z = z; W = w; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Int4 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Int4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out int x, out int y, out int z, out int w) {x = X; y = Y; z = Z; w = W; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Int4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Int4 x0, Int4 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Int4 x0, Int4 x1) => !x0.Equals(x1);

        public static Int4 Zero = new Int4(default, default, default, default);
        public static Int4 MinValue = new Int4(int.MinValue, int.MinValue, int.MinValue, int.MinValue);
        public static Int4 MaxValue = new Int4(int.MaxValue, int.MaxValue, int.MaxValue, int.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int4 SetX(int x) => new Int4(x, Y, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int4 SetY(int x) => new Int4(X, x, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int4 SetZ(int x) => new Int4(X, Y, x, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int4 SetW(int x) => new Int4(X, Y, Z, x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator +(Int4 value1, Int4 value2) => new Int4(value1.X + value2.X,value1.Y + value2.Y,value1.Z + value2.Z,value1.W + value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator +(Int4 value1, int value2) => new Int4(value1.X + value2,value1.Y + value2,value1.Z + value2,value1.W + value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator +(int value1, Int4 value2) => new Int4(value1 + value2.X,value1 + value2.Y,value1 + value2.Z,value1 + value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator -(Int4 value1, Int4 value2) => new Int4(value1.X - value2.X,value1.Y - value2.Y,value1.Z - value2.Z,value1.W - value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator -(Int4 value1, int value2) => new Int4(value1.X - value2,value1.Y - value2,value1.Z - value2,value1.W - value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator -(int value1, Int4 value2) => new Int4(value1 - value2.X,value1 - value2.Y,value1 - value2.Z,value1 - value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator *(Int4 value1, Int4 value2) => new Int4(value1.X * value2.X,value1.Y * value2.Y,value1.Z * value2.Z,value1.W * value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator *(Int4 value1, int value2) => new Int4(value1.X * value2,value1.Y * value2,value1.Z * value2,value1.W * value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator *(int value1, Int4 value2) => new Int4(value1 * value2.X,value1 * value2.Y,value1 * value2.Z,value1 * value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator /(Int4 value1, Int4 value2) => new Int4(value1.X / value2.X,value1.Y / value2.Y,value1.Z / value2.Z,value1.W / value2.W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator /(Int4 value1, int value2) => new Int4(value1.X / value2,value1.Y / value2,value1.Z / value2,value1.W / value2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator /(int value1, Int4 value2) => new Int4(value1 / value2.X,value1 / value2.Y,value1 / value2.Z,value1 / value2.W);
        public static Int4 One = new Int4(1);
        public static Int4 UnitX = Zero.SetX(1);
        public static Int4 UnitY = Zero.SetY(1);
        public static Int4 UnitZ = Zero.SetZ(1);
        public static Int4 UnitW = Zero.SetW(1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Int4(int value) : this(value, value, value, value) { }        
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Int4 operator -(Int4 value) => Zero - value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Dot(Int4 value1, Int4 value2) => value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z + value1.W * value2.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int Dot(Int4 value) => Int4.Dot(this, value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AlmostZero(float tolerance = Constants.Tolerance) => X.Abs() < tolerance && Y.Abs() < tolerance && Z.Abs() < tolerance && W.Abs() < tolerance;    
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsNaN() => X.IsNaN() || Y.IsNaN() || Z.IsNaN() || W.IsNaN();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool IsInfinity() => X.IsInfinity() || Y.IsInfinity() || Z.IsInfinity() || W.IsInfinity();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool AnyComponentNegative() => MinComponent() < 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int MinComponent() => (X).Min(Y).Min(Z).Min(W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int MaxComponent() => (X).Max(Y).Max(Z).Max(W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int SumComponents() => (X) + (Y) + (Z) + (W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int SumSqrComponents() => (X).Sqr() + (Y).Sqr() + (Z).Sqr() + (W).Sqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int ProductComponents() => (X) * (Y) * (Z) * (W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public int GetComponent(int n) => n == 0 ? X : n == 1 ? Y : n == 2 ? Z:W;        
        public const int NumComponents = 4;

    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Byte2 : IEquatable< Byte2 >
    {
        [DataMember]
        public readonly byte X;
        [DataMember]
        public readonly byte Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte2(byte x, byte y) { X = x; Y = y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Byte2 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Byte2(X = {X}, Y = {Y})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out byte x, out byte y) {x = X; y = Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Byte2 x) => X == x.X && Y == x.Y;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Byte2 x0, Byte2 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Byte2 x0, Byte2 x1) => !x0.Equals(x1);

        public static Byte2 Zero = new Byte2(default, default);
        public static Byte2 MinValue = new Byte2(byte.MinValue, byte.MinValue);
        public static Byte2 MaxValue = new Byte2(byte.MaxValue, byte.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte2 SetX(byte x) => new Byte2(x, Y);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte2 SetY(byte x) => new Byte2(X, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Byte3 : IEquatable< Byte3 >
    {
        [DataMember]
        public readonly byte X;
        [DataMember]
        public readonly byte Y;
        [DataMember]
        public readonly byte Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte3(byte x, byte y, byte z) { X = x; Y = y; Z = z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Byte3 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Byte3(X = {X}, Y = {Y}, Z = {Z})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out byte x, out byte y, out byte z) {x = X; y = Y; z = Z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Byte3 x) => X == x.X && Y == x.Y && Z == x.Z;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Byte3 x0, Byte3 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Byte3 x0, Byte3 x1) => !x0.Equals(x1);

        public static Byte3 Zero = new Byte3(default, default, default);
        public static Byte3 MinValue = new Byte3(byte.MinValue, byte.MinValue, byte.MinValue);
        public static Byte3 MaxValue = new Byte3(byte.MaxValue, byte.MaxValue, byte.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte3 SetX(byte x) => new Byte3(x, Y, Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte3 SetY(byte x) => new Byte3(X, x, Z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte3 SetZ(byte x) => new Byte3(X, Y, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct Byte4 : IEquatable< Byte4 >
    {
        [DataMember]
        public readonly byte X;
        [DataMember]
        public readonly byte Y;
        [DataMember]
        public readonly byte Z;
        [DataMember]
        public readonly byte W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte4(byte x, byte y, byte z, byte w) { X = x; Y = y; Z = z; W = w; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is Byte4 x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"Byte4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out byte x, out byte y, out byte z, out byte w) {x = X; y = Y; z = Z; w = W; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(Byte4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(Byte4 x0, Byte4 x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(Byte4 x0, Byte4 x1) => !x0.Equals(x1);

        public static Byte4 Zero = new Byte4(default, default, default, default);
        public static Byte4 MinValue = new Byte4(byte.MinValue, byte.MinValue, byte.MinValue, byte.MinValue);
        public static Byte4 MaxValue = new Byte4(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte4 SetX(byte x) => new Byte4(x, Y, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte4 SetY(byte x) => new Byte4(X, x, Z, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte4 SetZ(byte x) => new Byte4(X, Y, x, W);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public Byte4 SetW(byte x) => new Byte4(X, Y, Z, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct ColorRGB : IEquatable< ColorRGB >
    {
        [DataMember]
        public readonly byte R;
        [DataMember]
        public readonly byte G;
        [DataMember]
        public readonly byte B;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGB(byte r, byte g, byte b) { R = r; G = g; B = b; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is ColorRGB x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(R.GetHashCode(), G.GetHashCode(), B.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"ColorRGB(R = {R}, G = {G}, B = {B})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out byte r, out byte g, out byte b) {r = R; g = G; b = B; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(ColorRGB x) => R == x.R && G == x.G && B == x.B;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(ColorRGB x0, ColorRGB x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(ColorRGB x0, ColorRGB x1) => !x0.Equals(x1);

        public static ColorRGB Zero = new ColorRGB(default, default, default);
        public static ColorRGB MinValue = new ColorRGB(byte.MinValue, byte.MinValue, byte.MinValue);
        public static ColorRGB MaxValue = new ColorRGB(byte.MaxValue, byte.MaxValue, byte.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGB SetR(byte x) => new ColorRGB(x, G, B);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGB SetG(byte x) => new ColorRGB(R, x, B);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGB SetB(byte x) => new ColorRGB(R, G, x);
    }
    [StructLayout(LayoutKind.Sequential, Pack=4)]
    [DataContract]
    public readonly partial struct ColorRGBA : IEquatable< ColorRGBA >
    {
        [DataMember]
        public readonly byte R;
        [DataMember]
        public readonly byte G;
        [DataMember]
        public readonly byte B;
        [DataMember]
        public readonly byte A;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGBA(byte r, byte g, byte b, byte a) { R = r; G = g; B = b; A = a; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) => obj is ColorRGBA x && Equals(x);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() => Hash.Combine(R.GetHashCode(), G.GetHashCode(), B.GetHashCode(), A.GetHashCode());
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() => $"ColorRGBA(R = {R}, G = {G}, B = {B}, A = {A})";
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Deconstruct(out byte r, out byte g, out byte b, out byte a) {r = R; g = G; b = B; a = A; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(ColorRGBA x) => R == x.R && G == x.G && B == x.B && A == x.A;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(ColorRGBA x0, ColorRGBA x1) => x0.Equals(x1);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(ColorRGBA x0, ColorRGBA x1) => !x0.Equals(x1);

        public static ColorRGBA Zero = new ColorRGBA(default, default, default, default);
        public static ColorRGBA MinValue = new ColorRGBA(byte.MinValue, byte.MinValue, byte.MinValue, byte.MinValue);
        public static ColorRGBA MaxValue = new ColorRGBA(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGBA SetR(byte x) => new ColorRGBA(x, G, B, A);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGBA SetG(byte x) => new ColorRGBA(R, x, B, A);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGBA SetB(byte x) => new ColorRGBA(R, G, x, A);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] public ColorRGBA SetA(byte x) => new ColorRGBA(R, G, B, x);
    }
}
